@AGENTS.md

# CLAUDE.md — asepbagja-blog (Phoenix Blog Engine)

## Project Overview

A Phoenix blog engine that renders bilingual (English/Indonesian) markdown content from a separate GitHub repository (`asepbagja-content`). The engine has **no database** — all content lives in Git as markdown files, cached in ETS at runtime. Comments are also stored as markdown files committed via the GitHub API.

This is a migration from an existing Astro JS blog at asepbagja.com. All existing URLs must be preserved.

## Architecture

### Two-Repository Design

- **`asepbagja-content`** (separate repo): Markdown blog posts, comments, about pages, music/workspace JSON data. This is the "source of truth" for all content. Treat it as read-only from this app's perspective (except comment submission via GitHub API).
- **`asepbagja-blog`** (this repo): Phoenix app that clones the content repo, parses everything into ETS, and serves the website.

### Content Sync Strategy

On app startup, the content repo is cloned (or pulled) to a local directory (`priv/content/`). A webhook endpoint receives GitHub push events and triggers `git pull` + ETS cache refresh. All parsed content lives in memory via ETS — no database queries, no Ecto.

## Tech Stack & Dependencies

| Component | Choice | Notes |
|---|---|---|
| Framework | Phoenix 1.7+ | LiveView optional, standard controllers are fine |
| Database | **None** | No Ecto. Remove Ecto from supervision tree and deps if scaffolded with it |
| Markdown | `mdex` | Rust NIF, fast, GFM support, built-in syntax highlighting |
| Frontmatter | `yaml_elixir` | Parse YAML frontmatter from markdown files |
| HTTP client | `req` | For GitHub API calls (comment submission) |
| JSON | `jason` | For parsing music/workspace JSON data files |
| Caching | ETS (via custom GenServer) | All posts + comments held in memory |
| Deployment target | VPS | Dockerfile generated by mix phx.gen.release --docker |

### Do NOT use

- Ecto or any database adapter
- NimblePublisher (we need runtime refresh, not compile-time)
- LiveView for content pages (unnecessary complexity for static content)

## Content Repo Structure

The content repo (`asepbagja-content`) has this layout:

```
blog/
  en/
    2016-personal-challenges.md
    full-stack-clojure-project.md
    ...
  id/
    40km-pertama-bersepeda.md
    ...
about/
  en.md
  id.md
music/
  releases.json
workspace/
  en.json
comments/
  en/
    full-stack-clojure-project/
      001_2015-05-27T14-30-00Z.md
      002_2015-05-28T09-15-00Z.md
    ...
  id/
    ...
```

### Blog Post Frontmatter Schema

```yaml
---
title: "Post Title"
date: 2024-01-15
category: "programming"  # used in URL: /:lang/:category/:slug
featuredImage: "/blog-img/some-image.jpg"
summary: "Short description for listing pages and meta tags"
lang: "en"  # or "id"
---
```

The slug is derived from the filename (minus any date prefix).

### Comment File Schema

```yaml
---
author: "Jane Doe"
date: 2024-01-15T10:30:00Z
reply_to: null          # or "001" for threaded replies
source: "disqus"        # "disqus" for migrated, "web" for native
original_disqus_id: ""  # only for migrated comments
---

Comment body in markdown or HTML (migrated Disqus comments may contain HTML).
```

Comment filenames follow the pattern: `NNN_YYYY-MM-DDTHH-MM-SSZ.md` where NNN is a zero-padded sequence number.

## App Structure

```
lib/
  blog/
    content.ex          # GenServer: git clone/pull, parse all files, populate ETS
    post.ex             # Post struct: title, slug, date, category, lang, body_html, summary, featured_image
    comment.ex          # Comment struct: author, date, reply_to, source, body_html
    markdown.ex         # Split frontmatter from body, parse MD→HTML via mdex
    cache.ex            # ETS table wrapper: get/put posts, comments, pages
    github.ex           # GitHub API client: create comment files via Contents API
  blog_web/
    controllers/
      page_controller.ex      # Homepage, about, music, workspace
      post_controller.ex      # Blog listing + individual posts
      comment_controller.ex   # Comment form submission
      webhook_controller.ex   # GitHub webhook receiver
      feed_controller.ex      # RSS/Atom feeds
    components/
      layouts.ex              # App + root layouts
      core_components.ex      # Shared UI components
    router.ex
```

## Routing

Preserve the existing URL structure from the Astro site for SEO:

```elixir
# Router structure
scope "/", BlogWeb do
  get "/", PageController, :home                          # Homepage (English default)
  get "/id", PageController, :home_id                     # Indonesian homepage

  get "/:lang/about", PageController, :about              # About pages
  get "/:lang/music", PageController, :music              # Music page
  get "/:lang/workspace", PageController, :workspace      # Workspace page

  get "/:lang/:category", PostController, :index          # Post listing by category
  get "/:lang/:category/:slug", PostController, :show     # Individual post

  post "/:lang/:category/:slug/comments", CommentController, :create

  get "/:lang/feed.xml", FeedController, :rss             # RSS per language
  get "/sitemap.xml", FeedController, :sitemap
end

# API scope (no CSRF)
scope "/api", BlogWeb do
  post "/webhook/github", WebhookController, :github
end
```

**Important:** The `:lang` param must be validated as either `"en"` or `"id"`. Return 404 for anything else. The `:category` param comes from post frontmatter (e.g., `"programming"`, `"business"`, `"personal"`).

## Key Module Behaviors

### `Blog.Content` (GenServer)

- `init/1`: Clone content repo to `priv/content/` (or `git pull` if already exists). Parse all files. Populate ETS.
- `handle_cast(:refresh)`: Run `git pull`, re-parse changed files, update ETS.
- Parsing pipeline: list all `.md` files → for each, split frontmatter with `yaml_elixir` → parse body with `mdex` → build struct → insert into ETS.
- Parse comments the same way, grouped by post slug.
- Parse `music/releases.json` and `workspace/en.json` into ETS.

### `Blog.Cache` (ETS wrapper)

Tables and access patterns:

- `:blog_posts` — key: `{lang, slug}`, value: `%Post{}`
- `:blog_posts_by_category` — key: `{lang, category}`, value: `[%Post{}]` (sorted by date desc)
- `:blog_comments` — key: `{lang, slug}`, value: `[%Comment{}]` (sorted by date asc)
- `:blog_pages` — key: `{type, lang}`, value: parsed content (about pages, music, workspace)

### `Blog.Markdown`

```elixir
def parse(raw_content) do
  # 1. Split on second "---" to separate frontmatter from body
  # 2. Parse frontmatter with YamlElixir
  # 3. Parse body with MDex.to_html/2 (enable GFM tables, strikethrough, syntax highlighting)
  # 4. Return {frontmatter_map, body_html}
end
```

### `Blog.Github`

For comment submission:

1. Accept sanitized comment data
2. Generate filename: `NNN_YYYY-MM-DDTHH-MM-SSZ.md`
3. Build markdown content with frontmatter
4. PUT to `https://api.github.com/repos/OWNER/asepbagja-content/contents/comments/{lang}/{slug}/{filename}`
5. Use a GitHub personal access token stored in app config (never hardcoded)
6. The resulting push triggers the webhook → cache refresh

### `BlogWeb.WebhookController`

1. Verify `X-Hub-Signature-256` header against a shared secret
2. On valid push event, cast `:refresh` to `Blog.Content` GenServer
3. Return 200 immediately (refresh happens async)

## Configuration

```elixir
# config/runtime.exs
config :blog,
  content_repo_url: System.get_env("CONTENT_REPO_URL") || "https://github.com/asepbagja/asepbagja-content.git",
  content_local_path: System.get_env("CONTENT_LOCAL_PATH") || "priv/content",
  github_token: System.get_env("GITHUB_TOKEN"),         # for comment submission
  github_webhook_secret: System.get_env("GITHUB_WEBHOOK_SECRET"),
  github_repo_owner: System.get_env("GITHUB_REPO_OWNER") || "asepbagja",
  github_repo_name: System.get_env("GITHUB_REPO_NAME") || "asepbagja-content"
```

## Important Implementation Notes

### Content parsing

- Frontmatter uses `---` delimiters. Split on the second occurrence to separate YAML from markdown body.
- Post slugs are derived from filenames. Strip any leading date pattern if present (e.g., `2016-01-01-my-post.md` → `my-post`). But check the existing Astro site — some files may not have date prefixes. The slug must match whatever is in the current live URLs.
- Migrated Disqus comments may have HTML in the body instead of markdown. Detect and pass through HTML as-is. Use `mdex` only for markdown content.
- Featured images reference paths like `/blog-img/filename.jpg`. These are served separately (CDN or static files) — the Phoenix app does not need to serve them unless configured to.

### Security

- Sanitize all comment form input. Strip HTML tags from author name. Allow limited markdown in comment body.
- Rate-limit the comment submission endpoint.
- Validate GitHub webhook signatures on every request.
- Never expose the GitHub token in client-side code or logs.

### SEO

- Render proper `<title>`, `<meta description>`, Open Graph, and Twitter Card tags on every page.
- Generate `sitemap.xml` from all published posts.
- RSS feeds per language at `/:lang/feed.xml`.
- Canonical URLs on every page.
- Return proper 404 pages for missing content.

### Performance

- All content is in ETS — page renders should be sub-millisecond for data access.
- Set appropriate HTTP cache headers (ETag or Last-Modified based on git commit hash).
- gzip responses in production.

## Testing

- Test markdown parsing with sample files that have various frontmatter shapes.
- Test comment file generation and filename sequencing.
- Test webhook signature verification with valid and invalid signatures.
- Test routing: ensure `/:lang/:category/:slug` resolves correctly and unknown langs return 404.
- Test cache refresh: simulate git pull with changed files and verify ETS updates.

## Commands

```bash
mix deps.get          # Install dependencies
mix phx.server        # Start dev server
mix test              # Run tests
MIX_ENV=prod mix release  # Build release
```

## Style & Conventions

- Follow standard Elixir formatting (`mix format`).
- Use `@moduledoc` and `@doc` for all public modules and functions.
- Pattern match in function heads rather than using conditionals where possible.
- Use `with` for multi-step operations that can fail.
- Keep controller actions thin — delegate to context modules in `lib/blog/`.
- Templates use HEEx. Keep logic out of templates.
